<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CLI Reference: Loader - build-kg</title>
<style>
:root { --bg: #0d1117; --surface: #161b22; --border: #30363d; --text: #c9d1d9; --text-muted: #8b949e; --heading: #f0f6fc; --link: #58a6ff; --accent: #1f6feb; --green: #3fb950; --orange: #d29922; --red: #f85149; --purple: #bc8cff; --code-bg: #0d1117; --inline-code-bg: #1c2128; }
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Cascadia Code', 'Consolas', 'Liberation Mono', monospace; background: var(--bg); color: var(--text); line-height: 1.6; font-size: 16px; }
.container { max-width: 960px; margin: 0 auto; padding: 2rem 1.5rem; }
.hero { text-align: center; padding: 3rem 0; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
.hero h1 { font-size: 2.5rem; color: var(--heading); margin-bottom: 0.5rem; letter-spacing: -0.02em; }
.hero .tagline { font-size: 1.2rem; color: var(--text-muted); margin-bottom: 1.5rem; }
.hero .badges { display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap; }
.badge { display: inline-block; padding: 0.25rem 0.75rem; border-radius: 2rem; font-size: 0.8rem; font-weight: 600; border: 1px solid var(--border); color: var(--text-muted); }
.badge.green { border-color: var(--green); color: var(--green); }
.badge.blue { border-color: var(--link); color: var(--link); }
.badge.purple { border-color: var(--purple); color: var(--purple); }
section { margin-bottom: 3rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); }
section:last-child { border-bottom: none; }
h2 { font-size: 1.8rem; color: var(--heading); margin-bottom: 1rem; padding-top: 1rem; }
h3 { font-size: 1.3rem; color: var(--heading); margin: 1.5rem 0 0.75rem; }
p { margin-bottom: 1rem; } ul, ol { margin-bottom: 1rem; padding-left: 1.5rem; } li { margin-bottom: 0.25rem; }
a { color: var(--link); text-decoration: none; } a:hover { text-decoration: underline; }
pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 6px; padding: 1rem 1.25rem; overflow-x: auto; margin: 1rem 0; font-size: 0.875rem; line-height: 1.5; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace; font-size: 0.875em; }
:not(pre) > code { background: var(--inline-code-bg); padding: 0.15em 0.4em; border-radius: 3px; font-size: 0.85em; }
table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
th, td { text-align: left; padding: 0.6rem 0.8rem; border: 1px solid var(--border); }
th { background: var(--surface); color: var(--heading); font-weight: 600; }
tr:nth-child(even) { background: rgba(22, 27, 34, 0.5); }
footer { text-align: center; padding: 2rem 0; color: var(--text-muted); font-size: 0.85rem; }
@media (max-width: 700px) { .hero h1 { font-size: 2rem; } }
</style>
</head>
<body>

<nav style="position:sticky;top:0;z-index:100;background:var(--surface);border-bottom:1px solid var(--border);padding:0.75rem 1.5rem;display:flex;align-items:center;gap:1.5rem;font-size:0.9rem;backdrop-filter:blur(8px);">
  <a href="index.html" style="color:var(--heading);font-weight:700;text-decoration:none;">build-<span style="color:var(--link)">kg</span></a>
  <a href="documentation.html">Docs</a>
  <a href="guide.html">Guide</a>
  <a href="reference-load.html" style="color:var(--heading);">Loader</a>
  <a href="https://github.com/agtm1199/build-kg" style="margin-left:auto;">GitHub</a>
</nav>

<div class="container">

<div class="hero">
  <h1>build-kg</h1>
  <p class="tagline">CLI Reference: Loader</p>
  <div class="badges">
    <span class="badge green">build-kg-load</span>
    <span class="badge blue">PostgreSQL</span>
    <span class="badge purple">Pipeline Stage</span>
  </div>
</div>

<section>
  <h2>Overview</h2>
  <p>Load chunked JSON files into the <code>source_document</code> and <code>source_fragment</code> PostgreSQL tables. This bridges the chunker output to the parser, which reads from these tables. Supports both regulatory sources (with jurisdiction/authority metadata) and generic sources (metadata stored in JSONB).</p>
</section>

<section>
  <h2>Usage</h2>
  <pre><code>build-kg-load &lt;chunk_dir&gt; --manifest &lt;path&gt; [OPTIONS]</code></pre>
  <p>Or via Python module:</p>
  <pre><code>python -m build_kg.load &lt;chunk_dir&gt; --manifest &lt;path&gt; [OPTIONS]</code></pre>
</section>

<section>
  <h2>Arguments</h2>
  <table>
    <thead>
      <tr>
        <th>Argument</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>chunk_dir</code></td>
        <td>Directory containing JSON chunk files (output from <code>build-kg-chunk</code>)</td>
      </tr>
    </tbody>
  </table>
</section>

<section>
  <h2>Options</h2>
  <table>
    <thead>
      <tr>
        <th>Flag</th>
        <th>Default</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>--manifest PATH</code></td>
        <td><strong>(required)</strong></td>
        <td>Path to the <code>crawl_manifest.json</code> file with source metadata</td>
      </tr>
      <tr>
        <td><code>--dry-run</code></td>
        <td>off</td>
        <td>Preview what would be inserted without committing to the database</td>
      </tr>
    </tbody>
  </table>
</section>

<section>
  <h2>How It Works</h2>

  <h3>1. Scan Chunks</h3>
  <p>The loader recursively scans <code>chunk_dir</code> for files matching the pattern <code>*_chunk_*.json</code>. It groups chunks by their original source filename (from the <code>metadata.filename</code> field, or inferred from the chunk filename).</p>

  <h3>2. Match Sources</h3>
  <p>For each document group, the loader matches the chunk file path to a source entry in the manifest. Matching is done by checking if the <code>source_name</code> from the manifest appears in the chunk&rsquo;s file path.</p>
  <p>For example, if the manifest has a source with <code>&quot;source_name&quot;: &quot;sfa_food_regs&quot;</code>, and a chunk file is located at:</p>
  <pre><code>chunk_output/sfa_food_regs/legislation_depth0_20260218_chunk_1.json</code></pre>
  <p>The loader matches this chunk to the <code>sfa_food_regs</code> source because the string <code>sfa_food_regs</code> appears in the file path. This is why the chunker&rsquo;s directory structure preservation is important.</p>

  <h3>3. Apply Metadata</h3>
  <p>From the matched source entry, the loader extracts:</p>
  <ul>
    <li><code>authority</code> (e.g., <code>SFA</code>, <code>CFIA</code>) &mdash; nullable for generic topics</li>
    <li><code>jurisdiction</code> (e.g., <code>SG</code>, <code>CA</code>) &mdash; nullable for generic topics</li>
    <li><code>doc_type</code> (e.g., <code>regulation</code>, <code>act</code>, <code>guidance</code>) &mdash; nullable for generic topics</li>
    <li><code>title</code> and <code>url</code></li>
    <li><code>metadata</code> &mdash; arbitrary key-value data stored in the JSONB column</li>
  </ul>
  <p>If no source matches, the loader falls back to the <code>defaults</code> object in the manifest. For generic (non-regulatory) topics, these fields can be omitted entirely.</p>

  <h3>4. Insert Documents</h3>
  <p>For each unique source document (grouped by original filename), the loader inserts a row into <code>source_document</code>. If a document with the same <code>filepath</code> already exists (upsert), the existing row&rsquo;s <code>updated_at</code> timestamp is refreshed.</p>

  <h3>5. Insert Fragments</h3>
  <p>For each chunk within a document, the loader inserts a row into <code>source_fragment</code> with:</p>
  <ul>
    <li><code>excerpt</code>: The chunk text (minimum 10 characters; shorter chunks are skipped)</li>
    <li><code>context_before</code>: Last 200 characters of the preceding chunk (for parser context)</li>
    <li><code>context_after</code>: First 200 characters of the following chunk (for parser context)</li>
    <li><code>canonical_locator</code>: Section identifier from chunk metadata, or <code>{filename}_chunk_{N}</code> as fallback</li>
    <li>Inherited <code>jurisdiction</code>, <code>authority</code>, and <code>doc_type</code> from the parent document</li>
  </ul>

  <h3>6. Commit</h3>
  <p>Each document group is committed individually. If one document fails, the error is logged and the loader continues with the next document.</p>
</section>

<section>
  <h2>Examples</h2>

  <h3>Standard load</h3>
  <pre><code>build-kg-load ./chunk_output/ --manifest ./crawl_manifest.json</code></pre>

  <h3>Preview without committing</h3>
  <pre><code>build-kg-load ./chunk_output/ --manifest ./crawl_manifest.json --dry-run</code></pre>
  <p>Dry-run output:</p>
  <pre><code>[DRY RUN] Would insert:
  Document: legislation_depth0_20260218_143022
    Authority: SFA, Jurisdiction: SG
    Fragments: 11 (of 12 chunks)
  Document: food-safety_depth1_20260218_143025
    Authority: SFA, Jurisdiction: SG
    Fragments: 7 (of 8 chunks)

  Total: 2 documents, ~20 fragments

[DRY RUN] No data was written.</code></pre>

  <h3>Load from a specific pipeline run</h3>
  <pre><code>build-kg-load \
  ./pipelines/reg_sg_fb_20260218/chunk_output/ \
  --manifest ./pipelines/reg_sg_fb_20260218/crawl_manifest.json</code></pre>
</section>

<section>
  <h2>Database Requirements</h2>
  <p>The loader connects to PostgreSQL using the credentials in <code>.env</code> (or environment variables). The following must be in place before running:</p>
  <ol>
    <li><strong>Database running</strong>: <code>docker compose -f db/docker-compose.yml up -d</code></li>
    <li><strong>Tables created</strong>: The <code>source_document</code> and <code>source_fragment</code> tables are created by <code>db/init.sql</code>, which runs automatically on first container start. If you reset the database, the tables are recreated.</li>
    <li><strong>Metadata columns</strong>: The <code>jurisdiction</code> and <code>doc_type</code> columns are optional <code>TEXT</code> fields &mdash; any string value is accepted. For generic topics, these fields can be omitted from the manifest and will be stored as NULL in the database.</li>
  </ol>
</section>

<section>
  <h2>Source Matching Troubleshooting</h2>
  <p>If the loader prints &ldquo;Warning: No manifest match, using defaults&rdquo; for all documents, check:</p>
  <ol>
    <li><strong>Directory structure</strong>: The chunk output must preserve the <code>source_name</code> directory from crawling. If you crawled to <code>crawl_output/sfa_food_regs/</code> and chunked to <code>chunk_output/sfa_food_regs/</code>, the source name <code>sfa_food_regs</code> will appear in the path and match correctly.</li>
    <li><strong>Manifest source_name</strong>: Ensure each source in the manifest has a <code>source_name</code> field that matches the directory name used during crawling.</li>
    <li><strong>Case sensitivity</strong>: Source name matching is case-sensitive. Use the exact same casing in the manifest and directory names.</li>
  </ol>
</section>

<section>
  <h2>Output</h2>
  <p>The loader reports:</p>
  <pre><code>============================================================
  LOAD COMPLETE
============================================================
  Documents inserted:  12     # New source_document rows
  Documents skipped:   0      # Already existed (upsert)
  Fragments inserted:  2483   # New source_fragment rows
  Errors:              0      # Documents that failed
============================================================</code></pre>
  <p>After loading, you can verify the data:</p>
  <pre><code>python -m build_kg.verify</code></pre>
  <p>Or query directly:</p>
  <pre><code>SELECT jurisdiction, authority, COUNT(*)
FROM source_fragment
GROUP BY jurisdiction, authority
ORDER BY COUNT(*) DESC;</code></pre>
</section>

<footer>
  <p>build-kg &mdash; Apache 2.0 License &mdash; <a href="https://github.com/agtm1199/build-kg">GitHub</a></p>
</footer>

</div>
</body>
</html>
